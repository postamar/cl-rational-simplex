
(defun make-dense-basis (lp b)
  (let* ((bm (basis-matrix b))
	 (m (basis-matrix-size bm))
	 (db (make-array (list m m) :initial-element 0 :element-type 'rational)))
    (dotimes (k m db)
      (let* ((col-ref (aref (basis-header b) k))
	     (col (aref (lp-columns lp) col-ref)))
	(dotimes (l (length (column-row-refs col)))
	  (let* ((row-ref (aref (column-row-refs col) l))
		 (row-ind (aref (lp-active-row-inds lp) row-ref)))
	    (unless (= -1 row-ind)
	      (setf (aref db row-ind k)
		    (* (column-coef col) (aref (column-values col) l))))))))))



;;;; Verifies the LU decomposition
(defun lu-check (lp b)
  (let* ((bm (basis-matrix b))
	 (m (basis-matrix-size bm))
	 (ua (make-array (list m m) :initial-element 0 :element-type 'rational))
	 (lc (make-array m :initial-element 0 :element-type 'rational))
	 (ta (make-array (list m m) :initial-element 0 :element-type 'rational))
	 (da (make-dense-basis lp b)))
    ;; fill u
    (dotimes (k m)
      (let* ((l (aref (basis-matrix-l-columns bm) k))
	     (pivj (lu-eta-matrix-j l))
	     (pivi (aref (lu-eta-matrix-is l) 0)))
	(setf (aref ua pivi pivj) 1)))
    (dotimes (index (length (basis-matrix-u-columns bm)))
      (let* ((u (aref (basis-matrix-u-columns bm) index))
	     (j (lu-eta-matrix-j u)))
	(dotimes (r (length (lu-eta-matrix-is u)))
	  (let ((i (aref (lu-eta-matrix-is u) r)))
	    (setf (aref ua i j)
		  (* (lu-eta-matrix-coef u) (aref (lu-eta-matrix-vis u) r)))))))
    ;; compute
    (dotimes (k m)
      ;; reset l
      (let* ((l (aref (basis-matrix-l-columns bm) k))
	     (lj (lu-eta-matrix-j l)))
	(dotimes (i m)
	  (setf (aref lc i) 0))
	(dotimes (kl (length (lu-eta-matrix-is l)))
	  (setf (aref la (aref (lu-eta-matrix-is l) kl))
		(* (lu-eta-matrix-coef l) (aref (lu-eta-matrix-vis l) kl)))))
      ;; matrix multiplication
      (dotimes (i m)
	(dotimes (j m)
	  (let ((v 0))
	    (dotimes (km m)
	      (incf v (* (aref la i km) (aref da km j))))
	    (setf (aref ta i j) v))))
      ;; matrix copy
      (dotimes (i m)
	(dotimes (j m)
	  (setf (aref da i j) (aref ta i j)))))
    ;; check
    (print-2d-array da)
    (print-2d-array ua)
    (dotimes (i m)
      (dotimes (j m)
	(assert (= (aref da i j) (aref ua i j)))))))



;;;;
(defun check-btran (sd)
  (let* ((db (make-dense-basis (simplex-lp sd) (simplex-basis sd)))
	 (tr (simplex-tran sd))
	 (m (basis-matrix-size (basis-matrix (simplex-basis sd))))
	 (vs (make-nvector m 0 rational))
	 (vr (make-nvector m 0 rational))
	 (vt (make-nvector m 0 rational)))
    (dotimes (k (length (simplex-vector-indices sd)))
      (let ((i (aref (simplex-vector-indices sd) k)))
	(setf (aref vs i) (* (simplex-vector-coef sd)
			     (aref (simplex-vector-values sd) k)))))
    (dotimes (k (length (tran-indices (simplex-tran sd))))
      (setf (aref vr (aref (tran-indices tr) k))
	    (* (tran-coef tr) (aref (tran-values tr) k))))
    (dotimes (j m)
      (dotimes (i m)
	(incf (aref vt j)
	      (* (aref vr i)
		 (aref db i j)))))
  ;  (print (basis-header (simplex-basis sd)))
 ;  (print vr)
 ;  (print db)
 ;  (print vt)
 ;  (print vs)
 ;  (print '---)
    (dotimes (i m t)
      (assert (= (aref vt i) (aref vs i))))))
  

(defun check-ftran (sd)
  (let* ((db (make-dense-basis (simplex-lp sd) (simplex-basis sd)))
	 (tr (simplex-tran sd))
	 (m (basis-matrix-size (basis-matrix (simplex-basis sd))))
	 (vs (make-nvector m 0 rational))
	 (vr (make-nvector m 0 rational))
	 (vt (make-nvector m 0 rational)))
    (dotimes (k (length (simplex-vector-indices sd)))
      (let ((i (aref (simplex-vector-indices sd) k)))
	(setf (aref vs i) (* (simplex-vector-coef sd)
			     (aref (simplex-vector-values sd) k)))))
    (dotimes (k (length (tran-indices (simplex-tran sd))))
      (setf (aref vr (aref (tran-indices tr) k))
	    (* (tran-coef tr) (aref (tran-values tr) k))))
    (dotimes (i m)
      (dotimes (j m)
	(incf (aref vt i)
	      (* (aref vr j)
		 (aref db i j)))))
  ;  (print (list vr db vt vs))
    (dotimes (i m t)
      (assert (= (aref vt i) (aref vs i))))))





